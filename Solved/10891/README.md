# Cactus? Not cactus?
https://www.acmicpc.net/problem/10891
## 해결 과정
### 0. 이해하는데 오래 걸리는 문제. 이해하면은 너무 쉬운 문제다.
### 1. 양방향 그래프 구조를 가지고 있으며, 아무 노드에서 시작하여도 똑같은 결과임을 알 수 있다.
```c++
for (int i = 0; i < M; i++) {
	int u, v;
	cin >> u >> v;
	Graph[u].push_back(v);
	Graph[v].push_back(u);
}
```
양방향 그래프를 만들어준다.		
### 2. 1번 노드부터 DFS 탐색 시작하고, 현재 노드의 방문 횟수를 1씩 증가시키고 자식 노드들까지 DFS로 방문한다.
### 3. 해당 노드가 이미 방문되어있다면, 해당 노드의 족보 중에서 어떤 부모가 방문 횟수 2개이상 되어 있다면 이는 문제에서 주어진 목표랑 다르기 때문에 거짓을 반환한다.
이는 싸이클 1개여야 하는데, 2개이상 구성되었기에 선인장이 아니다.		
### 4. 처음에는 이해하기가 어려웠지만 나중에는 이해했다. 이는 SCC와 다르게 BCC를 적용한다는 것을 배웠다.