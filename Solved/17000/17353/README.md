# 하늘에서 떨어지는 1, 2, ..., R-L+1개의 별
https://www.acmicpc.net/problem/17353
## 해결 과정
### 0. lazy로 갱신하려다가 단순히 카운트를 해주기만 해도 되는 것을 알아챘음.
원래는 lazy로 갱신하면서 하려다가 원리를 보다 편리하게 할 수 있는 것이 count tree임을 알 수 있었다.
### 1. tree, count 배열을 0으로 초기화하면서 길이는 (트리의 높이 + 1)만큼 비트 자리 수 까지 선언함.
트리의 높이는 log2(N)의 값이 소수점 있다면 올림으로 처리하고 + 1 해준다.    
비트 자리 수 = (1 << 트리의 높이) 하면 자리 수가 나온다.   
### 2. 주어진 쿼리의 길이가 L, R 이라 하면 길이는 R - L + 1 이다.
### 3. 쿼리의 출력 인덱스 값을 Index라고 하고, L과 R 사이에 있다면 arr[Index] = Index - L + 1가 된다.
### 4. 업데이트를 할수록 arr[Index]에 값이 쌓아진다.
### 5. 출력하게 된다면 arr[Index]에 쌓인 값들을 합치고 출력하게 된다.
이 공식을 간단하게 바꾸면 (갱신을 호출한 횟수) * (Index + 1) - (L 값들의 합)   
즉, 각 원소마다 카운트 횟수가 새겨지고, 그 횟수이랑 L 값들의 합이랑 합치면 원하는 값으로 출력된다.    
